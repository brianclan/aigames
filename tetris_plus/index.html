<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Tetris Plus</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
        font-family: Arial, sans-serif;
        margin: 0;
        overflow: hidden;
      }
      canvas {
        border: 2px solid #333;
        background-color: #111;
        margin-top: 20px;
      }
      .controls {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }
      button {
        padding: 8px 16px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
      }
      button:hover {
        background-color: #45a049;
      }
      #pause {
        background-color: #f44336;
      }
      #pause:hover {
        background-color: #d32f2f;
      }
      .language-btn {
        background-color: #2196f3;
        margin-top: 10px;
      }
      .language-btn:hover {
        background-color: #0b7dda;
      }
      .info {
        margin-top: 20px;
        font-size: 18px;
      }
      .bomb-info {
        color: #f44336;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      }
      .bomb-tip {
        color: #666;
        font-style: italic;
        margin-top: 5px;
        font-size: 16px;
      }
      .rules-container {
        margin-top: 20px;
        max-width: 600px;
        text-align: left;
        border: 1px solid #ddd;
        padding: 10px 20px;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      .rules-container h3 {
        color: #333;
        margin-top: 10px;
        margin-bottom: 5px;
      }
      .rules-container ul {
        margin-top: 5px;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1 id="game-title">Tetris Plus</h1>
    <button id="switch-language" class="language-btn">
      åˆ‡æ¢ä¸ºä¸­æ–‡ / Switch to Chinese
    </button>

    <canvas id="tetris" width="300" height="600"></canvas>
    <div class="controls">
      <button id="left">â† Left</button>
      <button id="rotate">Rotate</button>
      <button id="right">Right â†’</button>
      <button id="down">Speed Down â†“</button>
      <button id="drop">Hard Drop (Space)</button>
      <button id="pause">Pause/Resume (Enter)</button>
    </div>
    <div class="info">
      <p><span id="score-label">Score</span>: <span id="score">0</span></p>
      <p><span id="level-label">Level</span>: <span id="level">1</span></p>
      <p class="bomb-info">
        ğŸ’£ <span id="small-bomb-label">Small Bomb</span>:
        <span id="small-bomb-desc">Destroys 3x3 area</span> (1/20 chance)
      </p>
      <p class="bomb-info">
        ğŸ’£ğŸ’£ <span id="medium-bomb-label">Medium Bomb</span>:
        <span id="medium-bomb-desc">Destroys 5x5 area</span> (1/40 chance)
      </p>
      <p class="bomb-info">
        ğŸ’£ğŸ’£ğŸ’£ <span id="large-bomb-label">Large Bomb</span>:
        <span id="large-bomb-desc">Destroys 7x7 area</span> (1/80 chance)
      </p>
      <p class="bomb-tip" id="bomb-tip">
        Press space key to detonate bombs immediately!
      </p>
    </div>

    <div class="rules-container" id="rules-container">
      <h2 id="rules-title">Game Rules</h2>
      <h3 id="basic-rules-title">Basic Rules</h3>
      <ul>
        <li id="rule-1">
          Random 1-6 connected blocks fall from the top of the screen
        </li>
        <li id="rule-2">
          Use arrow keys or on-screen buttons to move and rotate pieces
        </li>
        <li id="rule-3">
          Fill a complete horizontal line to clear it and earn points
        </li>
        <li id="rule-4">
          Game ends when blocks stack to the top of the screen
        </li>
      </ul>
      <h3 id="bomb-rules-title">Special Bomb Blocks</h3>
      <ul>
        <li id="bomb-rule-1">Bombs occasionally appear among normal blocks</li>
        <li id="bomb-rule-2">Bombs automatically detonate when they land</li>
        <li id="bomb-rule-3">
          Press Space to instantly detonate bombs while they're falling
        </li>
        <li id="bomb-rule-4">
          Larger bombs are rarer but destroy bigger areas
        </li>
      </ul>
      <h3 id="scoring-title">Scoring</h3>
      <ul>
        <li id="score-rule-1">
          Clearing lines: 100 points Ã— level Ã— number of lines
        </li>
        <li id="score-rule-2">Small Bomb: 300 points bonus</li>
        <li id="score-rule-3">Medium Bomb: 600 points bonus</li>
        <li id="score-rule-4">Large Bomb: 1000 points bonus</li>
      </ul>
    </div>

    <script>
      // Language Settings
      let currentLanguage = "en"; // Default language: English

      const translations = {
        en: {
          gameTitle: "Tetris Plus",
          switchLanguage: "åˆ‡æ¢ä¸ºä¸­æ–‡ / Switch to Chinese",
          left: "â† Left",
          rotate: "Rotate",
          right: "Right â†’",
          down: "Speed Down â†“",
          drop: "Hard Drop (Space)",
          pause: "Pause/Resume (Enter)",
          score: "Score",
          level: "Level",
          smallBomb: "Small Bomb",
          mediumBomb: "Medium Bomb",
          largeBomb: "Large Bomb",
          smallBombDesc: "Destroys 3x3 area",
          mediumBombDesc: "Destroys 5x5 area",
          largeBombDesc: "Destroys 7x7 area",
          bombTip: "Press space key to detonate bombs immediately!",
          gamePaused: "PAUSED",
          pressEnter: "Press Enter to continue",
          gameOver: "Game Over! Final Score: ",
          rulesTitle: "Game Rules",
          basicRulesTitle: "Basic Rules",
          rule1: "Random 1-6 connected blocks fall from the top of the screen",
          rule2:
            "Use arrow keys or on-screen buttons to move and rotate pieces",
          rule3: "Fill a complete horizontal line to clear it and earn points",
          rule4: "Game ends when blocks stack to the top of the screen",
          bombRulesTitle: "Special Bomb Blocks",
          bombRule1: "Bombs occasionally appear among normal blocks",
          bombRule2: "Bombs automatically detonate when they land",
          bombRule3:
            "Press Space to instantly detonate bombs while they're falling",
          bombRule4: "Larger bombs are rarer but destroy bigger areas",
          scoringTitle: "Scoring",
          scoreRule1: "Clearing lines: 100 points Ã— level Ã— number of lines",
          scoreRule2: "Small Bomb: 300 points bonus",
          scoreRule3: "Medium Bomb: 600 points bonus",
          scoreRule4: "Large Bomb: 1000 points bonus",
        },
        zh: {
          gameTitle: "ä¿„ç½—æ–¯æ–¹å—",
          switchLanguage: "Switch to English / åˆ‡æ¢ä¸ºè‹±æ–‡",
          left: "â† å·¦ç§»",
          rotate: "æ—‹è½¬",
          right: "å³ç§» â†’",
          down: "åŠ é€Ÿä¸‹è½ â†“",
          drop: "ä¸€é”®é€Ÿé™ (ç©ºæ ¼)",
          pause: "æš‚åœ/ç»§ç»­ (å›è½¦)",
          score: "åˆ†æ•°",
          level: "ç­‰çº§",
          smallBomb: "å°ç‚¸å¼¹",
          mediumBomb: "ä¸­ç‚¸å¼¹",
          largeBomb: "å¤§ç‚¸å¼¹",
          smallBombDesc: "ç‚¸æ‰3x3èŒƒå›´",
          mediumBombDesc: "ç‚¸æ‰5x5èŒƒå›´",
          largeBombDesc: "ç‚¸æ‰7x7èŒƒå›´",
          bombTip: "æŒ‰ç©ºæ ¼é”®å¯ä»¥ç«‹å³å¼•çˆ†ç‚¸å¼¹!",
          gamePaused: "å·²æš‚åœ",
          pressEnter: "æŒ‰å›è½¦é”®ç»§ç»­",
          gameOver: "æ¸¸æˆç»“æŸ! æœ€ç»ˆå¾—åˆ†: ",
          rulesTitle: "æ¸¸æˆè§„åˆ™",
          basicRulesTitle: "åŸºæœ¬è§„åˆ™",
          rule1: "éšæœº1-6ä¸ªç›¸è¿çš„æ–¹å—ä»å±å¹•é¡¶éƒ¨è½ä¸‹",
          rule2: "ä½¿ç”¨æ–¹å‘é”®æˆ–å±å¹•æŒ‰é’®ç§»åŠ¨å’Œæ—‹è½¬æ–¹å—",
          rule3: "å¡«æ»¡ä¸€æ•´è¡Œå¯ä»¥æ¶ˆé™¤å®ƒå¹¶è·å¾—åˆ†æ•°",
          rule4: "å½“æ–¹å—å †å åˆ°å±å¹•é¡¶éƒ¨æ—¶æ¸¸æˆç»“æŸ",
          bombRulesTitle: "ç‰¹æ®Šç‚¸å¼¹æ–¹å—",
          bombRule1: "ç‚¸å¼¹å¶å°”ä¼šå‡ºç°åœ¨æ™®é€šæ–¹å—ä¸­",
          bombRule2: "ç‚¸å¼¹è½åœ°åä¼šè‡ªåŠ¨å¼•çˆ†",
          bombRule3: "åœ¨ç‚¸å¼¹ä¸‹è½æ—¶æŒ‰ç©ºæ ¼é”®å¯ä»¥ç«‹å³å¼•çˆ†",
          bombRule4: "æ›´å¤§çš„ç‚¸å¼¹æ›´ç¨€æœ‰ï¼Œä½†å¯ä»¥æ‘§æ¯æ›´å¤§çš„åŒºåŸŸ",
          scoringTitle: "è®¡åˆ†è§„åˆ™",
          scoreRule1: "æ¶ˆé™¤è¡Œ: 100åˆ† Ã— ç­‰çº§ Ã— è¡Œæ•°",
          scoreRule2: "å°ç‚¸å¼¹: å¥–åŠ±300åˆ†",
          scoreRule3: "ä¸­ç‚¸å¼¹: å¥–åŠ±600åˆ†",
          scoreRule4: "å¤§ç‚¸å¼¹: å¥–åŠ±1000åˆ†",
        },
      };

      // Function to update UI language
      function updateLanguage(lang) {
        const t = translations[lang];

        // Update UI elements
        document.getElementById("game-title").textContent = t.gameTitle;
        document.getElementById("switch-language").textContent =
          t.switchLanguage;
        document.getElementById("left").textContent = t.left;
        document.getElementById("rotate").textContent = t.rotate;
        document.getElementById("right").textContent = t.right;
        document.getElementById("down").textContent = t.down;
        document.getElementById("drop").textContent = t.drop;
        document.getElementById("pause").textContent = t.pause;
        document.getElementById("score-label").textContent = t.score;
        document.getElementById("level-label").textContent = t.level;
        document.getElementById("small-bomb-label").textContent = t.smallBomb;
        document.getElementById("medium-bomb-label").textContent = t.mediumBomb;
        document.getElementById("large-bomb-label").textContent = t.largeBomb;
        document.getElementById("small-bomb-desc").textContent =
          t.smallBombDesc;
        document.getElementById("medium-bomb-desc").textContent =
          t.mediumBombDesc;
        document.getElementById("large-bomb-desc").textContent =
          t.largeBombDesc;
        document.getElementById("bomb-tip").textContent = t.bombTip;

        // Rules section
        document.getElementById("rules-title").textContent = t.rulesTitle;
        document.getElementById("basic-rules-title").textContent =
          t.basicRulesTitle;
        document.getElementById("rule-1").textContent = t.rule1;
        document.getElementById("rule-2").textContent = t.rule2;
        document.getElementById("rule-3").textContent = t.rule3;
        document.getElementById("rule-4").textContent = t.rule4;
        document.getElementById("bomb-rules-title").textContent =
          t.bombRulesTitle;
        document.getElementById("bomb-rule-1").textContent = t.bombRule1;
        document.getElementById("bomb-rule-2").textContent = t.bombRule2;
        document.getElementById("bomb-rule-3").textContent = t.bombRule3;
        document.getElementById("bomb-rule-4").textContent = t.bombRule4;
        document.getElementById("scoring-title").textContent = t.scoringTitle;
        document.getElementById("score-rule-1").textContent = t.scoreRule1;
        document.getElementById("score-rule-2").textContent = t.scoreRule2;
        document.getElementById("score-rule-3").textContent = t.scoreRule3;
        document.getElementById("score-rule-4").textContent = t.scoreRule4;
      }

      // Initialize with English language
      updateLanguage(currentLanguage);

      // Language switch button handler
      document
        .getElementById("switch-language")
        .addEventListener("click", () => {
          currentLanguage = currentLanguage === "en" ? "zh" : "en";
          updateLanguage(currentLanguage);
        });

      // æ¸¸æˆå¸¸é‡
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 30;
      const COLORS = [
        null,
        "#FF0D72", // çº¢è‰²
        "#0DC2FF", // è“è‰²
        "#0DFF72", // ç»¿è‰²
        "#F538FF", // ç´«è‰²
        "#FF8E0D", // æ©™è‰²
        "#FFE138", // é»„è‰²
        "#3877FF", // æ·±è“
      ];
      const BOMB_COLOR = "#000000"; // ç‚¸å¼¹é¢œè‰²ï¼ˆé»‘è‰²ï¼‰
      const BOMB_VALUE = 8; // ç‚¸å¼¹çš„å€¼ï¼Œä¸æ™®é€šæ–¹å—åŒºåˆ†å¼€
      const BOMB_FLASH_SPEED = 300; // ç‚¸å¼¹é—ªçƒé€Ÿåº¦ï¼ˆæ¯«ç§’ï¼‰

      // ç‚¸å¼¹ç±»å‹å¸¸é‡
      const SMALL_BOMB = 8; // 1x1 ç‚¸å¼¹ï¼Œç‚¸3x3èŒƒå›´
      const MEDIUM_BOMB = 9; // 2x2 ç‚¸å¼¹ï¼Œç‚¸5x5èŒƒå›´
      const LARGE_BOMB = 10; // 3x3 ç‚¸å¼¹ï¼Œç‚¸7x7èŒƒå›´

      // ç‚¸å¼¹æ¦‚ç‡ (åˆ†åˆ«æ˜¯ 1/20, 1/40, 1/80)
      const SMALL_BOMB_CHANCE = 0.05; // 1/20
      const MEDIUM_BOMB_CHANCE = 0.025; // 1/40
      const LARGE_BOMB_CHANCE = 0.0125; // 1/80

      // æ¸¸æˆå˜é‡
      let canvas = document.getElementById("tetris");
      let ctx = canvas.getContext("2d");
      let scoreElement = document.getElementById("score");
      let levelElement = document.getElementById("level");
      let score = 0;
      let level = 1;
      let dropCounter = 0;
      let dropInterval = 1000;
      let lastTime = 0;
      let gameOver = false;
      let paused = false;
      let bombFlashState = false; // ç‚¸å¼¹é—ªçƒçŠ¶æ€
      let lastBombFlashTime = 0; // ä¸Šæ¬¡ç‚¸å¼¹é—ªçƒçš„æ—¶é—´

      // ç»˜åˆ¶å•ä¸ªæ–¹å—
      function drawBlock(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      }

      // ç»˜åˆ¶ç‚¸å¼¹æ–¹å—ï¼ˆé—ªçƒæ•ˆæœï¼‰
      function drawBombBlock(x, y, bombType) {
        // æ ¹æ®ç‚¸å¼¹ç±»å‹é€‰æ‹©é¢œè‰²
        let color;

        switch (bombType) {
          case SMALL_BOMB:
            color = bombFlashState ? "#FF0000" : BOMB_COLOR;
            break;
          case MEDIUM_BOMB:
            color = bombFlashState ? "#FF6600" : "#330000";
            break;
          case LARGE_BOMB:
            color = bombFlashState ? "#FF9900" : "#660000";
            break;
          default:
            color = bombFlashState ? "#FF0000" : BOMB_COLOR;
        }

        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

        // ç»˜åˆ¶ç‚¸å¼¹æ ‡å¿—
        const centerX = (x + 0.5) * BLOCK_SIZE;
        const centerY = (y + 0.5) * BLOCK_SIZE;
        const radius = BLOCK_SIZE / 5;

        // æ ¹æ®ç‚¸å¼¹ç±»å‹è°ƒæ•´ç‚¸å¼¹æ ·å¼
        if (bombType === MEDIUM_BOMB) {
          // ä¸­å‹ç‚¸å¼¹æ ·å¼ï¼ˆé»„è‰²åœ†å½¢ï¼‰
          ctx.fillStyle = "#FFFF00";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();

          // ä¸­å‹ç‚¸å¼¹å¼•çº¿
          ctx.strokeStyle = "#FFFFFF";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - radius);
          ctx.lineTo(centerX, centerY - radius * 2);
          ctx.stroke();
        } else if (bombType === LARGE_BOMB) {
          // å¤§å‹ç‚¸å¼¹æ ·å¼ï¼ˆæ©™è‰²åœ†å½¢ï¼‰
          ctx.fillStyle = "#FFA500";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
          ctx.fill();

          // å¤§å‹ç‚¸å¼¹å¼•çº¿
          ctx.strokeStyle = "#FFFFFF";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - radius);
          ctx.lineTo(centerX, centerY - radius * 2.5);
          ctx.stroke();
        } else {
          // å°å‹ç‚¸å¼¹æ ·å¼ï¼ˆç™½è‰²åœ†å½¢ï¼‰
          ctx.fillStyle = "#FFFFFF";
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();

          // å°å‹ç‚¸å¼¹å¼•çº¿
          ctx.strokeStyle = "#FFFF00";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - radius);
          ctx.lineTo(centerX, centerY - radius * 2);
          ctx.stroke();
        }

        // ç»˜åˆ¶ç«èŠ±
        if (bombFlashState) {
          // ç«èŠ±é¢œè‰²æ ¹æ®ç‚¸å¼¹ç±»å‹å˜åŒ–
          let sparkColor;
          let sparkSize;

          switch (bombType) {
            case SMALL_BOMB:
              sparkColor = "#FFFF00";
              sparkSize = radius / 2;
              break;
            case MEDIUM_BOMB:
              sparkColor = "#FFFFFF";
              sparkSize = radius / 1.5;
              break;
            case LARGE_BOMB:
              sparkColor = "#FFFF99";
              sparkSize = radius;
              break;
            default:
              sparkColor = "#FFFF00";
              sparkSize = radius / 2;
          }

          ctx.fillStyle = sparkColor;
          ctx.beginPath();

          if (bombType === LARGE_BOMB) {
            // å¤§å‹ç‚¸å¼¹æœ‰æ˜Ÿå½¢ç«èŠ±
            drawStar(
              centerX,
              centerY - radius * 2.5,
              5,
              sparkSize,
              sparkSize / 2
            );
          } else {
            // å…¶ä»–ç‚¸å¼¹æœ‰åœ†å½¢ç«èŠ±
            ctx.arc(
              centerX,
              centerY - (bombType === MEDIUM_BOMB ? radius * 2 : radius * 2),
              sparkSize,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }
      }

      // ç»˜åˆ¶æ˜Ÿå½¢
      function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = (Math.PI / 2) * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          ctx.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          ctx.lineTo(x, y);
          rot += step;
        }

        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fill();
      }

      // åˆ›å»ºæ¸¸æˆæ¿
      function createMatrix(w, h) {
        const matrix = [];
        while (h--) {
          matrix.push(new Array(w).fill(0));
        }
        return matrix;
      }

      let board = createMatrix(COLS, ROWS);

      // éšæœºç”Ÿæˆ1-6ä¸ªç›¸è¿æ–¹å—ç»„æˆçš„å›¾å½¢
      function createPiece() {
        // ç”Ÿæˆç‚¸å¼¹çš„æ¦‚ç‡æ£€æŸ¥
        const random = Math.random();
        if (random < LARGE_BOMB_CHANCE) {
          return createLargeBomb();
        } else if (random < MEDIUM_BOMB_CHANCE + LARGE_BOMB_CHANCE) {
          return createMediumBomb();
        } else if (
          random <
          SMALL_BOMB_CHANCE + MEDIUM_BOMB_CHANCE + LARGE_BOMB_CHANCE
        ) {
          return createSmallBomb();
        }

        const size = Math.floor(Math.random() * 6) + 1;
        const piece = [];
        for (let y = 0; y < size; y++) {
          piece[y] = [];
          for (let x = 0; x < size; x++) {
            piece[y][x] = 0;
          }
        }

        const color = Math.floor(Math.random() * (COLORS.length - 1)) + 1;
        const centerX = Math.floor(size / 2);
        const centerY = Math.floor(size / 2);
        piece[centerY][centerX] = color;

        let blocksPlaced = 1;
        let maxAttempts = 100; // é˜²æ­¢æ— é™å¾ªç¯
        while (blocksPlaced < size && maxAttempts > 0) {
          let startX, startY;
          do {
            startX = Math.floor(Math.random() * size);
            startY = Math.floor(Math.random() * size);
            maxAttempts--;
            if (maxAttempts <= 0) break;
          } while (piece[startY][startX] !== color);

          if (maxAttempts <= 0) break;

          const directions = [
            [0, 1],
            [1, 0],
            [0, -1],
            [-1, 0],
          ];
          const [dx, dy] =
            directions[Math.floor(Math.random() * directions.length)];
          const newX = startX + dx;
          const newY = startY + dy;

          if (
            newX >= 0 &&
            newX < size &&
            newY >= 0 &&
            newY < size &&
            piece[newY][newX] === 0
          ) {
            piece[newY][newX] = color;
            blocksPlaced++;
          }
        }

        return trimPiece(piece);
      }

      // åˆ›å»ºå°ç‚¸å¼¹æ–¹å—ï¼ˆ1x1å¤§å°ï¼‰
      function createSmallBomb() {
        // åˆ›å»ºä¸€ä¸ª1x1çš„ç‚¸å¼¹æ–¹å—
        return [[SMALL_BOMB]];
      }

      // åˆ›å»ºä¸­å‹ç‚¸å¼¹æ–¹å—ï¼ˆ2x2å¤§å°ï¼‰
      function createMediumBomb() {
        // åˆ›å»ºä¸€ä¸ª2x2çš„ç‚¸å¼¹æ–¹å—
        return [
          [MEDIUM_BOMB, MEDIUM_BOMB],
          [MEDIUM_BOMB, MEDIUM_BOMB],
        ];
      }

      // åˆ›å»ºå¤§å‹ç‚¸å¼¹æ–¹å—ï¼ˆ3x3å¤§å°ï¼‰
      function createLargeBomb() {
        // åˆ›å»ºä¸€ä¸ª3x3çš„ç‚¸å¼¹æ–¹å—
        return [
          [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB],
          [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB],
          [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB],
        ];
      }

      // ç§»é™¤å›¾å½¢ä¸­çš„ç©ºè¡Œå’Œç©ºåˆ—
      function trimPiece(piece) {
        // é˜²æ­¢ç©ºçŸ©é˜µå¯¼è‡´é”™è¯¯
        if (!piece || piece.length === 0) {
          return [[1]]; // è¿”å›ä¸€ä¸ªé»˜è®¤çš„1x1æ–¹å—
        }

        let trimmed = piece.filter((row) => row.some((val) => val !== 0));

        // å¦‚æœæ‰€æœ‰è¡Œéƒ½æ˜¯ç©ºçš„ï¼Œè¿”å›é»˜è®¤æ–¹å—
        if (trimmed.length === 0) {
          return [[1]];
        }

        // ç¡®ä¿trimmed[0]å­˜åœ¨å†ç»§ç»­å¤„ç†
        if (trimmed.length > 0) {
          const colsToRemove = [];
          for (let x = 0; x < trimmed[0].length; x++) {
            let isEmpty = true;
            for (let y = 0; y < trimmed.length; y++) {
              if (trimmed[y][x] !== 0) {
                isEmpty = false;
                break;
              }
            }
            if (isEmpty) colsToRemove.push(x);
          }

          for (let i = colsToRemove.length - 1; i >= 0; i--) {
            for (let y = 0; y < trimmed.length; y++) {
              trimmed[y].splice(colsToRemove[i], 1);
            }
          }

          // å¦‚æœæ‰€æœ‰åˆ—éƒ½è¢«ç§»é™¤ï¼Œè¿”å›é»˜è®¤æ–¹å—
          if (trimmed[0].length === 0) {
            return [[1]];
          }
        }

        return trimmed;
      }

      // ç»˜åˆ¶æ¸¸æˆæ¿å’Œå½“å‰æ–¹å—
      function draw() {
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // å¤„ç†ç‚¸å¼¹é—ªçƒ
        const currentTime = Date.now();
        if (currentTime - lastBombFlashTime > BOMB_FLASH_SPEED) {
          bombFlashState = !bombFlashState;
          lastBombFlashTime = currentTime;
        }

        // ç»˜åˆ¶æ¸¸æˆæ¿
        for (let y = 0; y < board.length; y++) {
          // ç¡®ä¿è¡Œå­˜åœ¨
          if (!board[y]) continue;

          for (let x = 0; x < board[y].length; x++) {
            if (board[y][x]) {
              const colorIndex = board[y][x];

              // å¦‚æœæ˜¯ç‚¸å¼¹æ–¹å—ï¼Œä½¿ç”¨ç‰¹æ®Šç»˜åˆ¶
              if (
                colorIndex === SMALL_BOMB ||
                colorIndex === MEDIUM_BOMB ||
                colorIndex === LARGE_BOMB
              ) {
                drawBombBlock(x, y, colorIndex);
              } else if (
                colorIndex >= 0 &&
                colorIndex < COLORS.length &&
                COLORS[colorIndex]
              ) {
                // ç¡®ä¿é¢œè‰²ç´¢å¼•æœ‰æ•ˆ
                drawBlock(x, y, COLORS[colorIndex]);
              }
            }
          }
        }

        // ç»˜åˆ¶å½“å‰æ–¹å—
        if (player.piece && player.pos) {
          player.piece.forEach((row, y) => {
            // ç¡®ä¿è¡Œå­˜åœ¨
            if (!row) return;

            row.forEach((value, x) => {
              if (value !== 0) {
                const colorIndex = value;

                // å¦‚æœæ˜¯ç‚¸å¼¹æ–¹å—ï¼Œä½¿ç”¨ç‰¹æ®Šç»˜åˆ¶
                if (
                  colorIndex === SMALL_BOMB ||
                  colorIndex === MEDIUM_BOMB ||
                  colorIndex === LARGE_BOMB
                ) {
                  drawBombBlock(x + player.pos.x, y + player.pos.y, colorIndex);
                } else if (
                  colorIndex >= 0 &&
                  colorIndex < COLORS.length &&
                  COLORS[colorIndex]
                ) {
                  // ç¡®ä¿é¢œè‰²ç´¢å¼•æœ‰æ•ˆ
                  drawBlock(
                    x + player.pos.x,
                    y + player.pos.y,
                    COLORS[colorIndex]
                  );
                }
              }
            });
          });
        }
      }

      // åˆå¹¶æ–¹å—åˆ°æ¸¸æˆæ¿
      function merge() {
        // å®‰å…¨æ£€æŸ¥
        if (!player.piece || !player.pos) return;

        let hasBomb = false;
        let bombX = -1,
          bombY = -1;
        let bombType = 0;

        player.piece.forEach((row, y) => {
          // ç¡®ä¿è¡Œå­˜åœ¨
          if (!row) return;

          row.forEach((value, x) => {
            if (value !== 0) {
              // æ£€æŸ¥è¾¹ç•Œï¼Œç¡®ä¿ä¸ä¼šå†™å…¥æ— æ•ˆä½ç½®
              if (
                y + player.pos.y >= 0 &&
                y + player.pos.y < ROWS &&
                x + player.pos.x >= 0 &&
                x + player.pos.x < COLS
              ) {
                // æ£€æŸ¥æ˜¯å¦ä¸ºç‚¸å¼¹
                if (
                  value === SMALL_BOMB ||
                  value === MEDIUM_BOMB ||
                  value === LARGE_BOMB
                ) {
                  hasBomb = true;
                  bombX = x + player.pos.x;
                  bombY = y + player.pos.y;
                  bombType = value;
                }

                board[y + player.pos.y][x + player.pos.x] = value;
              }
            }
          });
        });

        // å¦‚æœåŒ…å«ç‚¸å¼¹ï¼Œæ‰§è¡Œçˆ†ç‚¸æ•ˆæœ
        if (hasBomb) {
          // å»¶è¿Ÿçˆ†ç‚¸ï¼Œè®©ç©å®¶çœ‹åˆ°ç‚¸å¼¹è½ä¸‹
          setTimeout(() => {
            explodeBomb(bombX, bombY, bombType);
          }, 500);
        }
      }

      // ç‚¸å¼¹çˆ†ç‚¸æ•ˆæœ
      function explodeBomb(bombX, bombY, bombType) {
        // æ ¹æ®ç‚¸å¼¹ç±»å‹ç¡®å®šçˆ†ç‚¸èŒƒå›´
        let explosionRadius;
        let scoreBonus;

        switch (bombType) {
          case SMALL_BOMB:
            explosionRadius = 1; // 3x3 èŒƒå›´
            scoreBonus = 300;
            break;
          case MEDIUM_BOMB:
            explosionRadius = 2; // 5x5 èŒƒå›´
            scoreBonus = 600;
            break;
          case LARGE_BOMB:
            explosionRadius = 3; // 7x7 èŒƒå›´
            scoreBonus = 1000;
            break;
          default:
            explosionRadius = 1;
            scoreBonus = 300;
        }

        // æ’­æ”¾çˆ†ç‚¸åŠ¨ç”»ï¼ˆé—ªçƒå‡ æ¬¡ï¼‰
        let flashCount = 0;
        const maxFlashes = 5;
        const flashInterval = setInterval(() => {
          bombFlashState = !bombFlashState;
          flashCount++;

          if (flashCount >= maxFlashes) {
            clearInterval(flashInterval);

            // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
            drawExplosion(bombX, bombY, bombType);

            // æ‰§è¡Œçˆ†ç‚¸ï¼Œæ¸…é™¤æŒ‡å®šèŒƒå›´å†…çš„æ–¹å—
            for (
              let y = bombY - explosionRadius;
              y <= bombY + explosionRadius;
              y++
            ) {
              for (
                let x = bombX - explosionRadius;
                x <= bombX + explosionRadius;
                x++
              ) {
                if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                  board[y][x] = 0;
                }
              }
            }

            // çˆ†ç‚¸åå¢åŠ åˆ†æ•°
            score += scoreBonus;
            scoreElement.textContent = score;

            // æ£€æŸ¥æ˜¯å¦æœ‰è¡Œå¯ä»¥æ¸…é™¤
            boardSweep();

            // æ£€æŸ¥å‡çº§
            const newLevel = Math.floor(score / 1000) + 1;
            if (newLevel > level) {
              level = newLevel;
              levelElement.textContent = level;
              dropInterval = Math.max(100, 1000 - (level - 1) * 100);
            }
          }
        }, 100);
      }

      // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
      function drawExplosion(bombX, bombY, bombType) {
        // æ ¹æ®ç‚¸å¼¹ç±»å‹ç¡®å®šçˆ†ç‚¸æ•ˆæœå¤§å°
        let radius;
        let particles;

        switch (bombType) {
          case SMALL_BOMB:
            radius = BLOCK_SIZE * 2;
            particles = 30;
            break;
          case MEDIUM_BOMB:
            radius = BLOCK_SIZE * 3;
            particles = 50;
            break;
          case LARGE_BOMB:
            radius = BLOCK_SIZE * 4;
            particles = 80;
            break;
          default:
            radius = BLOCK_SIZE * 2;
            particles = 30;
        }

        // çˆ†ç‚¸åŠ¨ç”»å‚æ•°
        const centerX = (bombX + 0.5) * BLOCK_SIZE;
        const centerY = (bombY + 0.5) * BLOCK_SIZE;

        // åˆ›å»ºç²’å­æ•ˆæœ
        for (let i = 0; i < particles; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * radius;
          const particleX = centerX + Math.cos(angle) * distance;
          const particleY = centerY + Math.sin(angle) * distance;
          const particleSize = Math.random() * 8 + 2;

          // æ ¹æ®ç‚¸å¼¹ç±»å‹é€‰æ‹©é¢œè‰²
          let color;
          switch (bombType) {
            case SMALL_BOMB:
              color = `hsl(${Math.random() * 60}, 100%, 50%)`; // çº¢åˆ°é»„è‰²
              break;
            case MEDIUM_BOMB:
              color = `hsl(${Math.random() * 30 + 20}, 100%, 50%)`; // æ©™åˆ°çº¢è‰²
              break;
            case LARGE_BOMB:
              color = `hsl(${Math.random() * 360}, 100%, 50%)`; // å…¨è‰²è°±
              break;
            default:
              color = `hsl(${Math.random() * 60}, 100%, 50%)`;
          }

          // ç»˜åˆ¶ç²’å­
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
          ctx.fill();
        }

        // ç»˜åˆ¶çˆ†ç‚¸ä¸­å¿ƒçš„å…‰åœˆ
        let gradient;
        switch (bombType) {
          case SMALL_BOMB:
            gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              radius
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(0.3, "rgba(255, 200, 0, 0.6)");
            gradient.addColorStop(0.7, "rgba(255, 0, 0, 0.4)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            break;
          case MEDIUM_BOMB:
            gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              radius
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.9)");
            gradient.addColorStop(0.2, "rgba(255, 220, 0, 0.7)");
            gradient.addColorStop(0.5, "rgba(255, 100, 0, 0.5)");
            gradient.addColorStop(0.8, "rgba(255, 0, 0, 0.3)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            break;
          case LARGE_BOMB:
            gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              radius
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 1.0)");
            gradient.addColorStop(0.1, "rgba(255, 255, 200, 0.9)");
            gradient.addColorStop(0.3, "rgba(255, 220, 0, 0.8)");
            gradient.addColorStop(0.5, "rgba(255, 100, 0, 0.6)");
            gradient.addColorStop(0.7, "rgba(255, 0, 0, 0.4)");
            gradient.addColorStop(0.9, "rgba(100, 0, 0, 0.2)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            break;
          default:
            gradient = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              radius
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(0.3, "rgba(255, 200, 0, 0.6)");
            gradient.addColorStop(0.7, "rgba(255, 0, 0, 0.4)");
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
        }

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // ç¢°æ’æ£€æµ‹
      function collide() {
        // å®‰å…¨æ£€æŸ¥
        if (!player.piece) return false;

        const [m, o] = [player.piece, player.pos];

        // æ£€æŸ¥ç©å®¶ä½ç½®æ˜¯å¦åˆæ³•
        if (o === undefined || o.x === undefined || o.y === undefined) {
          return false;
        }

        for (let y = 0; y < m.length; y++) {
          // ç¡®ä¿è¡Œå­˜åœ¨
          if (!m[y]) continue;

          for (let x = 0; x < m[y].length; x++) {
            if (
              m[y][x] !== 0 &&
              (board[y + o.y] === undefined ||
                board[y + o.y][x + o.x] === undefined ||
                board[y + o.y][x + o.x] !== 0)
            ) {
              return true;
            }
          }
        }
        return false;
      }

      // ä¿®å¤åçš„æ—‹è½¬å‡½æ•° - å®ç°çœŸæ­£çš„90åº¦æ—‹è½¬
      function rotate() {
        // å¦‚æœæ²¡æœ‰æ–¹å—ï¼Œç›´æ¥è¿”å›
        if (
          !player.piece ||
          player.piece.length === 0 ||
          player.piece[0].length === 0
        ) {
          return;
        }

        // åˆ›å»ºæ—‹è½¬åçš„æ–°çŸ©é˜µ
        const original = player.piece;
        const N = original.length;
        const M = original[0].length;
        const rotated = [];

        // åˆå§‹åŒ–æ—‹è½¬åçš„çŸ©é˜µ
        for (let i = 0; i < M; i++) {
          rotated[i] = new Array(N).fill(0);
        }

        // æ‰§è¡Œ90åº¦é¡ºæ—¶é’ˆæ—‹è½¬
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < M; x++) {
            rotated[x][N - 1 - y] = original[y][x];
          }
        }

        // ä¿å­˜åŸå§‹ä½ç½®
        const originalPos = {...player.pos};
        const originalPiece = player.piece;

        // å°è¯•æ—‹è½¬
        player.piece = rotated;

        // å¦‚æœæ—‹è½¬åå‘ç”Ÿç¢°æ’ï¼Œå°è¯•è°ƒæ•´ä½ç½®
        if (collide()) {
          let offset = 1;
          while (offset <= 2) {
            // æœ€å¤šå°è¯•å·¦å³ç§»åŠ¨2æ ¼
            // å°è¯•å‘å³ç§»åŠ¨
            player.pos.x += offset;
            if (!collide()) break;

            // å°è¯•å‘å·¦ç§»åŠ¨
            player.pos.x = originalPos.x - offset;
            if (!collide()) break;

            // æ¢å¤åŸå§‹ä½ç½®
            player.pos.x = originalPos.x;
            offset++;
          }

          // å¦‚æœè°ƒæ•´åä»ç„¶ç¢°æ’ï¼Œæ¢å¤åŸå§‹çŠ¶æ€
          if (collide()) {
            player.piece = originalPiece;
            player.pos = originalPos;
          }
        }
      }

      // æ¸…é™¤å®Œæ•´çš„è¡Œ
      function boardSweep() {
        let linesCleared = 0;
        outer: for (let y = board.length - 1; y >= 0; y--) {
          for (let x = 0; x < board[y].length; x++) {
            if (board[y][x] === 0) {
              continue outer;
            }
          }

          const row = board.splice(y, 1)[0].fill(0);
          board.unshift(row);
          y++;
          linesCleared++;
        }

        if (linesCleared > 0) {
          score += linesCleared * 100 * level;
          scoreElement.textContent = score;

          const newLevel = Math.floor(score / 1000) + 1;
          if (newLevel > level) {
            level = newLevel;
            levelElement.textContent = level;
            dropInterval = Math.max(100, 1000 - (level - 1) * 100);
          }
        }
      }

      // é‡ç½®ç©å®¶ä½ç½®å’Œæ–¹å—
      function playerReset() {
        player.piece = createPiece();
        player.pos.y = 0;

        // ç¡®ä¿ player.piece å’Œ player.piece[0] å­˜åœ¨
        if (!player.piece || !player.piece[0]) {
          player.piece = [[1]]; // ä½¿ç”¨é»˜è®¤æ–¹å—
        }

        player.pos.x = Math.floor((COLS - player.piece[0].length) / 2);

        if (collide()) {
          gameOver = true;
          alert(`${translations[currentLanguage].gameOver}${score}`);
          board = createMatrix(COLS, ROWS);
          score = 0;
          level = 1;
          dropInterval = 1000;
          scoreElement.textContent = score;
          levelElement.textContent = level;
          gameOver = false; // é‡ç½®æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿å¯ä»¥é‡æ–°å¼€å§‹
        }
      }

      // ç©å®¶æ§åˆ¶
      const player = {
        pos: {x: 0, y: 0},
        piece: null,
      };

      // ç©å®¶ç§»åŠ¨
      function playerMove(dir) {
        // å®‰å…¨æ£€æŸ¥
        if (!player.piece || !player.pos) return;

        player.pos.x += dir;
        if (collide()) {
          player.pos.x -= dir;
        }
      }

      // ç©å®¶ä¸‹è½
      function playerDrop() {
        // å®‰å…¨æ£€æŸ¥
        if (!player.piece || !player.pos) return;

        player.pos.y++;
        if (collide()) {
          player.pos.y--;
          merge();
          boardSweep();
          playerReset();
        }
        dropCounter = 0;
      }

      // ä¸€é”®é€Ÿé™
      function hardDrop() {
        // å®‰å…¨æ£€æŸ¥
        if (!player.piece || !player.pos) return;

        // æ£€æŸ¥å½“å‰æ–¹å—æ˜¯å¦ä¸ºç‚¸å¼¹ï¼Œå¦‚æœæ˜¯åˆ™ç«‹å³å¼•çˆ†
        if (isBomb(player.piece)) {
          detonateBomb();
          return;
        }

        // é™åˆ¶ä¸‹è½æ¬¡æ•°ï¼Œé˜²æ­¢æ— é™å¾ªç¯
        let maxDrops = ROWS;
        while (!collide() && maxDrops > 0) {
          player.pos.y++;
          maxDrops--;
        }
        player.pos.y--;
        merge();
        boardSweep();
        playerReset();
        dropCounter = 0;
      }

      // æ£€æŸ¥æ–¹å—æ˜¯å¦ä¸ºç‚¸å¼¹
      function isBomb(piece) {
        for (let y = 0; y < piece.length; y++) {
          for (let x = 0; x < piece[y].length; x++) {
            if (
              piece[y][x] === SMALL_BOMB ||
              piece[y][x] === MEDIUM_BOMB ||
              piece[y][x] === LARGE_BOMB
            ) {
              return true;
            }
          }
        }
        return false;
      }

      // ç«‹å³å¼•çˆ†å½“å‰ç‚¸å¼¹
      function detonateBomb() {
        if (!player.piece || !player.pos) return;

        let bombX = -1,
          bombY = -1;
        let bombType = 0;
        let hasBomb = false;

        // å¯»æ‰¾ç‚¸å¼¹ä½ç½®ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ç‚¸å¼¹ï¼‰
        outer: for (let y = 0; y < player.piece.length; y++) {
          for (let x = 0; x < player.piece[y].length; x++) {
            if (
              player.piece[y][x] === SMALL_BOMB ||
              player.piece[y][x] === MEDIUM_BOMB ||
              player.piece[y][x] === LARGE_BOMB
            ) {
              bombX = x + player.pos.x;
              bombY = y + player.pos.y;
              bombType = player.piece[y][x];
              hasBomb = true;
              break outer;
            }
          }
        }

        if (hasBomb) {
          // ç«‹å³å¼•çˆ†ç‚¸å¼¹
          explodeBomb(bombX, bombY, bombType);

          // æ¸…é™¤å½“å‰æ–¹å—
          player.piece = null;

          // ç”Ÿæˆæ–°æ–¹å—
          playerReset();
        }
      }

      // æ¸¸æˆä¸»å¾ªç¯
      function update(time = 0) {
        if (gameOver) {
          // ä¸ç«‹å³é‡ç½®æ¸¸æˆçŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·å“åº”
          // gameOver = false;
          return;
        }

        // å¦‚æœæ¸¸æˆæš‚åœï¼Œåªç»˜åˆ¶å½“å‰çŠ¶æ€å¹¶ç»§ç»­è¯·æ±‚ä¸‹ä¸€å¸§
        if (paused) {
          // åœ¨ç”»é¢ä¸­å¤®æ˜¾ç¤ºæš‚åœä¿¡æ¯
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.font = "30px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(
            translations[currentLanguage].gamePaused,
            canvas.width / 2,
            canvas.height / 2
          );
          ctx.font = "16px Arial";
          ctx.fillText(
            translations[currentLanguage].pressEnter,
            canvas.width / 2,
            canvas.height / 2 + 30
          );

          requestAnimationFrame(update);
          return;
        }

        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          playerDrop();
        }

        draw();
        requestAnimationFrame(update);
      }

      // é”®ç›˜æ§åˆ¶
      document.addEventListener("keydown", (event) => {
        if (gameOver) return;

        if ([13, 32, 37, 38, 39, 40].includes(event.keyCode)) {
          event.preventDefault();
        }

        // å¤„ç†å›è½¦é”®æš‚åœ/ç»§ç»­
        if (event.keyCode === 13) {
          // å›è½¦é”®
          paused = !paused; // åˆ‡æ¢æš‚åœçŠ¶æ€
          return;
        }

        // å¦‚æœæ¸¸æˆå·²æš‚åœï¼Œä¸å¤„ç†å…¶ä»–æŒ‰é”®
        if (paused) return;

        switch (event.keyCode) {
          case 37: // å·¦ç®­å¤´
            playerMove(-1);
            break;
          case 39: // å³ç®­å¤´
            playerMove(1);
            break;
          case 40: // ä¸‹ç®­å¤´
            playerDrop();
            break;
          case 38: // ä¸Šç®­å¤´
            rotate();
            break;
          case 32: // ç©ºæ ¼é”®
            hardDrop();
            break;
        }
      });

      // æŒ‰é’®æ§åˆ¶
      document.getElementById("left").addEventListener("click", () => {
        if (!gameOver && !paused) playerMove(-1);
      });
      document.getElementById("right").addEventListener("click", () => {
        if (!gameOver && !paused) playerMove(1);
      });
      document.getElementById("rotate").addEventListener("click", () => {
        if (!gameOver && !paused) rotate();
      });
      document.getElementById("down").addEventListener("click", () => {
        if (!gameOver && !paused) playerDrop();
      });
      document.getElementById("drop").addEventListener("click", () => {
        if (!gameOver && !paused) hardDrop();
      });
      document.getElementById("pause").addEventListener("click", () => {
        if (!gameOver) paused = !paused;
      });

      // å¼€å§‹æ¸¸æˆ
      playerReset();
      update();
    </script>
  </body>
</html>
