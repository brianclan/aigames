<!DOCTYPE html>
<html>
<head>
    <title>ä¿„ç½—æ–¯æ–¹å—</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #333;
            background-color: #111;
            margin-top: 20px;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        #pause {
            background-color: #f44336;
        }
        #pause:hover {
            background-color: #d32f2f;
        }
        .info {
            margin-top: 20px;
            font-size: 18px;
        }
        .bomb-info {
            color: #f44336;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .bomb-tip {
            color: #666;
            font-style: italic;
            margin-top: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>ä¿„ç½—æ–¯æ–¹å—</h1>
    <canvas id="tetris" width="300" height="600"></canvas>
    <div class="controls">
        <button id="left">â† å·¦ç§»</button>
        <button id="rotate">æ—‹è½¬</button>
        <button id="right">å³ç§» â†’</button>
        <button id="down">åŠ é€Ÿä¸‹è½ â†“</button>
        <button id="drop">ä¸€é”®é€Ÿé™ (ç©ºæ ¼)</button>
        <button id="pause">æš‚åœ/ç»§ç»­ (å›è½¦)</button>
    </div>
    <div class="info">
        <p>åˆ†æ•°: <span id="score">0</span></p>
        <p>ç­‰çº§: <span id="level">1</span></p>
        <p class="bomb-info">ğŸ’£ å°ç‚¸å¼¹: ç‚¸æ‰3x3èŒƒå›´ (1/20æ¦‚ç‡)</p>
        <p class="bomb-info">ğŸ’£ğŸ’£ ä¸­ç‚¸å¼¹: ç‚¸æ‰5x5èŒƒå›´ (1/40æ¦‚ç‡)</p>
        <p class="bomb-info">ğŸ’£ğŸ’£ğŸ’£ å¤§ç‚¸å¼¹: ç‚¸æ‰7x7èŒƒå›´ (1/80æ¦‚ç‡)</p>
        <p class="bomb-tip">æŒ‰ç©ºæ ¼é”®å¯ä»¥ç«‹å³å¼•çˆ†ç‚¸å¼¹!</p>
    </div>

    <script>
        // æ¸¸æˆå¸¸é‡
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = [
            null,
            '#FF0D72', // çº¢è‰²
            '#0DC2FF', // è“è‰²
            '#0DFF72', // ç»¿è‰²
            '#F538FF', // ç´«è‰²
            '#FF8E0D', // æ©™è‰²
            '#FFE138', // é»„è‰²
            '#3877FF'  // æ·±è“
        ];
        const BOMB_COLOR = '#000000'; // ç‚¸å¼¹é¢œè‰²ï¼ˆé»‘è‰²ï¼‰
        const BOMB_VALUE = 8; // ç‚¸å¼¹çš„å€¼ï¼Œä¸æ™®é€šæ–¹å—åŒºåˆ†å¼€
        const BOMB_FLASH_SPEED = 300; // ç‚¸å¼¹é—ªçƒé€Ÿåº¦ï¼ˆæ¯«ç§’ï¼‰
        
        // ç‚¸å¼¹ç±»å‹å¸¸é‡
        const SMALL_BOMB = 8;  // 1x1 ç‚¸å¼¹ï¼Œç‚¸3x3èŒƒå›´
        const MEDIUM_BOMB = 9; // 2x2 ç‚¸å¼¹ï¼Œç‚¸5x5èŒƒå›´
        const LARGE_BOMB = 10; // 3x3 ç‚¸å¼¹ï¼Œç‚¸7x7èŒƒå›´
        
        // ç‚¸å¼¹æ¦‚ç‡ (åˆ†åˆ«æ˜¯ 1/20, 1/40, 1/80)
        const SMALL_BOMB_CHANCE = 0.05;  // 1/20
        const MEDIUM_BOMB_CHANCE = 0.025; // 1/40
        const LARGE_BOMB_CHANCE = 0.0125; // 1/80
        
        // æ¸¸æˆå˜é‡
        let canvas = document.getElementById('tetris');
        let ctx = canvas.getContext('2d');
        let scoreElement = document.getElementById('score');
        let levelElement = document.getElementById('level');
        let score = 0;
        let level = 1;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let gameOver = false;
        let paused = false;
        let bombFlashState = false; // ç‚¸å¼¹é—ªçƒçŠ¶æ€
        let lastBombFlashTime = 0; // ä¸Šæ¬¡ç‚¸å¼¹é—ªçƒçš„æ—¶é—´

        // ç»˜åˆ¶å•ä¸ªæ–¹å—
        function drawBlock(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
        
        // ç»˜åˆ¶ç‚¸å¼¹æ–¹å—ï¼ˆé—ªçƒæ•ˆæœï¼‰
        function drawBombBlock(x, y, bombType) {
            // æ ¹æ®ç‚¸å¼¹ç±»å‹é€‰æ‹©é¢œè‰²
            let color;
            
            switch(bombType) {
                case SMALL_BOMB:
                    color = bombFlashState ? '#FF0000' : BOMB_COLOR;
                    break;
                case MEDIUM_BOMB:
                    color = bombFlashState ? '#FF6600' : '#330000';
                    break;
                case LARGE_BOMB:
                    color = bombFlashState ? '#FF9900' : '#660000';
                    break;
                default:
                    color = bombFlashState ? '#FF0000' : BOMB_COLOR;
            }
            
            ctx.fillStyle = color;
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#000';
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            // ç»˜åˆ¶ç‚¸å¼¹æ ‡å¿—
            const centerX = (x + 0.5) * BLOCK_SIZE;
            const centerY = (y + 0.5) * BLOCK_SIZE;
            const radius = BLOCK_SIZE / 5;
            
            // æ ¹æ®ç‚¸å¼¹ç±»å‹è°ƒæ•´ç‚¸å¼¹æ ·å¼
            if (bombType === MEDIUM_BOMB) {
                // ä¸­å‹ç‚¸å¼¹æ ·å¼ï¼ˆé»„è‰²åœ†å½¢ï¼‰
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å‹ç‚¸å¼¹å¼•çº¿
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY - radius * 2);
                ctx.stroke();
            } else if (bombType === LARGE_BOMB) {
                // å¤§å‹ç‚¸å¼¹æ ·å¼ï¼ˆæ©™è‰²åœ†å½¢ï¼‰
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤§å‹ç‚¸å¼¹å¼•çº¿
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY - radius * 2.5);
                ctx.stroke();
            } else {
                // å°å‹ç‚¸å¼¹æ ·å¼ï¼ˆç™½è‰²åœ†å½¢ï¼‰
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // å°å‹ç‚¸å¼¹å¼•çº¿
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY - radius * 2);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç«èŠ±
            if (bombFlashState) {
                // ç«èŠ±é¢œè‰²æ ¹æ®ç‚¸å¼¹ç±»å‹å˜åŒ–
                let sparkColor;
                let sparkSize;
                
                switch(bombType) {
                    case SMALL_BOMB:
                        sparkColor = '#FFFF00';
                        sparkSize = radius / 2;
                        break;
                    case MEDIUM_BOMB:
                        sparkColor = '#FFFFFF';
                        sparkSize = radius / 1.5;
                        break;
                    case LARGE_BOMB:
                        sparkColor = '#FFFF99';
                        sparkSize = radius;
                        break;
                    default:
                        sparkColor = '#FFFF00';
                        sparkSize = radius / 2;
                }
                
                ctx.fillStyle = sparkColor;
                ctx.beginPath();
                
                if (bombType === LARGE_BOMB) {
                    // å¤§å‹ç‚¸å¼¹æœ‰æ˜Ÿå½¢ç«èŠ±
                    drawStar(centerX, centerY - radius * 2.5, 5, sparkSize, sparkSize / 2);
                } else {
                    // å…¶ä»–ç‚¸å¼¹æœ‰åœ†å½¢ç«èŠ±
                    ctx.arc(centerX, centerY - (bombType === MEDIUM_BOMB ? radius * 2 : radius * 2), 
                        sparkSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // ç»˜åˆ¶æ˜Ÿå½¢
        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            let step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        // åˆ›å»ºæ¸¸æˆæ¿
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        let board = createMatrix(COLS, ROWS);

        // éšæœºç”Ÿæˆ1-6ä¸ªç›¸è¿æ–¹å—ç»„æˆçš„å›¾å½¢
        function createPiece() {
            // ç”Ÿæˆç‚¸å¼¹çš„æ¦‚ç‡æ£€æŸ¥
            const random = Math.random();
            if (random < LARGE_BOMB_CHANCE) {
                return createLargeBomb();
            } else if (random < MEDIUM_BOMB_CHANCE + LARGE_BOMB_CHANCE) {
                return createMediumBomb();
            } else if (random < SMALL_BOMB_CHANCE + MEDIUM_BOMB_CHANCE + LARGE_BOMB_CHANCE) {
                return createSmallBomb();
            }
            
            const size = Math.floor(Math.random() * 6) + 1;
            const piece = [];
            for (let y = 0; y < size; y++) {
                piece[y] = [];
                for (let x = 0; x < size; x++) {
                    piece[y][x] = 0;
                }
            }
            
            const color = Math.floor(Math.random() * (COLORS.length - 1)) + 1;
            const centerX = Math.floor(size / 2);
            const centerY = Math.floor(size / 2);
            piece[centerY][centerX] = color;
            
            let blocksPlaced = 1;
            let maxAttempts = 100; // é˜²æ­¢æ— é™å¾ªç¯
            while (blocksPlaced < size && maxAttempts > 0) {
                let startX, startY;
                do {
                    startX = Math.floor(Math.random() * size);
                    startY = Math.floor(Math.random() * size);
                    maxAttempts--;
                    if (maxAttempts <= 0) break;
                } while (piece[startY][startX] !== color);
                
                if (maxAttempts <= 0) break;
                
                const directions = [
                    [0, 1], [1, 0], [0, -1], [-1, 0]
                ];
                const [dx, dy] = directions[Math.floor(Math.random() * directions.length)];
                const newX = startX + dx;
                const newY = startY + dy;
                
                if (newX >= 0 && newX < size && newY >= 0 && newY < size && piece[newY][newX] === 0) {
                    piece[newY][newX] = color;
                    blocksPlaced++;
                }
            }
            
            return trimPiece(piece);
        }
        
        // åˆ›å»ºå°ç‚¸å¼¹æ–¹å—ï¼ˆ1x1å¤§å°ï¼‰
        function createSmallBomb() {
            // åˆ›å»ºä¸€ä¸ª1x1çš„ç‚¸å¼¹æ–¹å—
            return [[SMALL_BOMB]];
        }
        
        // åˆ›å»ºä¸­å‹ç‚¸å¼¹æ–¹å—ï¼ˆ2x2å¤§å°ï¼‰
        function createMediumBomb() {
            // åˆ›å»ºä¸€ä¸ª2x2çš„ç‚¸å¼¹æ–¹å—
            return [
                [MEDIUM_BOMB, MEDIUM_BOMB],
                [MEDIUM_BOMB, MEDIUM_BOMB]
            ];
        }
        
        // åˆ›å»ºå¤§å‹ç‚¸å¼¹æ–¹å—ï¼ˆ3x3å¤§å°ï¼‰
        function createLargeBomb() {
            // åˆ›å»ºä¸€ä¸ª3x3çš„ç‚¸å¼¹æ–¹å—
            return [
                [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB],
                [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB],
                [LARGE_BOMB, LARGE_BOMB, LARGE_BOMB]
            ];
        }

        // ç§»é™¤å›¾å½¢ä¸­çš„ç©ºè¡Œå’Œç©ºåˆ—
        function trimPiece(piece) {
            // é˜²æ­¢ç©ºçŸ©é˜µå¯¼è‡´é”™è¯¯
            if (!piece || piece.length === 0) {
                return [[1]]; // è¿”å›ä¸€ä¸ªé»˜è®¤çš„1x1æ–¹å—
            }
            
            let trimmed = piece.filter(row => row.some(val => val !== 0));
            
            // å¦‚æœæ‰€æœ‰è¡Œéƒ½æ˜¯ç©ºçš„ï¼Œè¿”å›é»˜è®¤æ–¹å—
            if (trimmed.length === 0) {
                return [[1]];
            }
            
            // ç¡®ä¿trimmed[0]å­˜åœ¨å†ç»§ç»­å¤„ç†
            if (trimmed.length > 0) {
                const colsToRemove = [];
                for (let x = 0; x < trimmed[0].length; x++) {
                    let isEmpty = true;
                    for (let y = 0; y < trimmed.length; y++) {
                        if (trimmed[y][x] !== 0) {
                            isEmpty = false;
                            break;
                        }
                    }
                    if (isEmpty) colsToRemove.push(x);
                }
                
                for (let i = colsToRemove.length - 1; i >= 0; i--) {
                    for (let y = 0; y < trimmed.length; y++) {
                        trimmed[y].splice(colsToRemove[i], 1);
                    }
                }
                
                // å¦‚æœæ‰€æœ‰åˆ—éƒ½è¢«ç§»é™¤ï¼Œè¿”å›é»˜è®¤æ–¹å—
                if (trimmed[0].length === 0) {
                    return [[1]];
                }
            }
            
            return trimmed;
        }

        // ç»˜åˆ¶æ¸¸æˆæ¿å’Œå½“å‰æ–¹å—
        function draw() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å¤„ç†ç‚¸å¼¹é—ªçƒ
            const currentTime = Date.now();
            if (currentTime - lastBombFlashTime > BOMB_FLASH_SPEED) {
                bombFlashState = !bombFlashState;
                lastBombFlashTime = currentTime;
            }
            
            // ç»˜åˆ¶æ¸¸æˆæ¿
            for (let y = 0; y < board.length; y++) {
                // ç¡®ä¿è¡Œå­˜åœ¨
                if (!board[y]) continue;
                
                for (let x = 0; x < board[y].length; x++) {
                    if (board[y][x]) {
                        const colorIndex = board[y][x];
                        
                        // å¦‚æœæ˜¯ç‚¸å¼¹æ–¹å—ï¼Œä½¿ç”¨ç‰¹æ®Šç»˜åˆ¶
                        if (colorIndex === SMALL_BOMB || colorIndex === MEDIUM_BOMB || colorIndex === LARGE_BOMB) {
                            drawBombBlock(x, y, colorIndex);
                        } else if (colorIndex >= 0 && colorIndex < COLORS.length && COLORS[colorIndex]) {
                            // ç¡®ä¿é¢œè‰²ç´¢å¼•æœ‰æ•ˆ
                            drawBlock(x, y, COLORS[colorIndex]);
                        }
                    }
                }
            }
            
            // ç»˜åˆ¶å½“å‰æ–¹å—
            if (player.piece && player.pos) {
                player.piece.forEach((row, y) => {
                    // ç¡®ä¿è¡Œå­˜åœ¨
                    if (!row) return;
                    
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            const colorIndex = value;
                            
                            // å¦‚æœæ˜¯ç‚¸å¼¹æ–¹å—ï¼Œä½¿ç”¨ç‰¹æ®Šç»˜åˆ¶
                            if (colorIndex === SMALL_BOMB || colorIndex === MEDIUM_BOMB || colorIndex === LARGE_BOMB) {
                                drawBombBlock(x + player.pos.x, y + player.pos.y, colorIndex);
                            } else if (colorIndex >= 0 && colorIndex < COLORS.length && COLORS[colorIndex]) {
                                // ç¡®ä¿é¢œè‰²ç´¢å¼•æœ‰æ•ˆ
                                drawBlock(x + player.pos.x, y + player.pos.y, COLORS[colorIndex]);
                            }
                        }
                    });
                });
            }
        }

        // åˆå¹¶æ–¹å—åˆ°æ¸¸æˆæ¿
        function merge() {
            // å®‰å…¨æ£€æŸ¥
            if (!player.piece || !player.pos) return;
            
            let hasBomb = false;
            let bombX = -1, bombY = -1;
            let bombType = 0;
            
            player.piece.forEach((row, y) => {
                // ç¡®ä¿è¡Œå­˜åœ¨
                if (!row) return;
                
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // æ£€æŸ¥è¾¹ç•Œï¼Œç¡®ä¿ä¸ä¼šå†™å…¥æ— æ•ˆä½ç½®
                        if (y + player.pos.y >= 0 && y + player.pos.y < ROWS && 
                            x + player.pos.x >= 0 && x + player.pos.x < COLS) {
                            
                            // æ£€æŸ¥æ˜¯å¦ä¸ºç‚¸å¼¹
                            if (value === SMALL_BOMB || value === MEDIUM_BOMB || value === LARGE_BOMB) {
                                hasBomb = true;
                                bombX = x + player.pos.x;
                                bombY = y + player.pos.y;
                                bombType = value;
                            }
                            
                            board[y + player.pos.y][x + player.pos.x] = value;
                        }
                    }
                });
            });
            
            // å¦‚æœåŒ…å«ç‚¸å¼¹ï¼Œæ‰§è¡Œçˆ†ç‚¸æ•ˆæœ
            if (hasBomb) {
                // å»¶è¿Ÿçˆ†ç‚¸ï¼Œè®©ç©å®¶çœ‹åˆ°ç‚¸å¼¹è½ä¸‹
                setTimeout(() => {
                    explodeBomb(bombX, bombY, bombType);
                }, 500);
            }
        }
        
        // ç‚¸å¼¹çˆ†ç‚¸æ•ˆæœ
        function explodeBomb(bombX, bombY, bombType) {
            // æ ¹æ®ç‚¸å¼¹ç±»å‹ç¡®å®šçˆ†ç‚¸èŒƒå›´
            let explosionRadius;
            let scoreBonus;
            
            switch(bombType) {
                case SMALL_BOMB:
                    explosionRadius = 1; // 3x3 èŒƒå›´
                    scoreBonus = 300;
                    break;
                case MEDIUM_BOMB:
                    explosionRadius = 2; // 5x5 èŒƒå›´
                    scoreBonus = 600;
                    break;
                case LARGE_BOMB:
                    explosionRadius = 3; // 7x7 èŒƒå›´
                    scoreBonus = 1000;
                    break;
                default:
                    explosionRadius = 1;
                    scoreBonus = 300;
            }
            
            // æ’­æ”¾çˆ†ç‚¸åŠ¨ç”»ï¼ˆé—ªçƒå‡ æ¬¡ï¼‰
            let flashCount = 0;
            const maxFlashes = 5;
            const flashInterval = setInterval(() => {
                bombFlashState = !bombFlashState;
                flashCount++;
                
                if (flashCount >= maxFlashes) {
                    clearInterval(flashInterval);
                    
                    // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
                    drawExplosion(bombX, bombY, bombType);
                    
                    // æ‰§è¡Œçˆ†ç‚¸ï¼Œæ¸…é™¤æŒ‡å®šèŒƒå›´å†…çš„æ–¹å—
                    for (let y = bombY - explosionRadius; y <= bombY + explosionRadius; y++) {
                        for (let x = bombX - explosionRadius; x <= bombX + explosionRadius; x++) {
                            if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                                board[y][x] = 0;
                            }
                        }
                    }
                    
                    // çˆ†ç‚¸åå¢åŠ åˆ†æ•°
                    score += scoreBonus;
                    scoreElement.textContent = score;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰è¡Œå¯ä»¥æ¸…é™¤
                    boardSweep();
                    
                    // æ£€æŸ¥å‡çº§
                    const newLevel = Math.floor(score / 1000) + 1;
                    if (newLevel > level) {
                        level = newLevel;
                        levelElement.textContent = level;
                        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                    }
                }
            }, 100);
        }
        
        // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
        function drawExplosion(bombX, bombY, bombType) {
            // æ ¹æ®ç‚¸å¼¹ç±»å‹ç¡®å®šçˆ†ç‚¸æ•ˆæœå¤§å°
            let radius;
            let particles;
            
            switch(bombType) {
                case SMALL_BOMB:
                    radius = BLOCK_SIZE * 2;
                    particles = 30;
                    break;
                case MEDIUM_BOMB:
                    radius = BLOCK_SIZE * 3;
                    particles = 50;
                    break;
                case LARGE_BOMB:
                    radius = BLOCK_SIZE * 4;
                    particles = 80;
                    break;
                default:
                    radius = BLOCK_SIZE * 2;
                    particles = 30;
            }
            
            // çˆ†ç‚¸åŠ¨ç”»å‚æ•°
            const centerX = (bombX + 0.5) * BLOCK_SIZE;
            const centerY = (bombY + 0.5) * BLOCK_SIZE;
            
            // åˆ›å»ºç²’å­æ•ˆæœ
            for (let i = 0; i < particles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const particleX = centerX + Math.cos(angle) * distance;
                const particleY = centerY + Math.sin(angle) * distance;
                const particleSize = Math.random() * 8 + 2;
                
                // æ ¹æ®ç‚¸å¼¹ç±»å‹é€‰æ‹©é¢œè‰²
                let color;
                switch(bombType) {
                    case SMALL_BOMB:
                        color = `hsl(${Math.random() * 60}, 100%, 50%)`; // çº¢åˆ°é»„è‰²
                        break;
                    case MEDIUM_BOMB:
                        color = `hsl(${Math.random() * 30 + 20}, 100%, 50%)`; // æ©™åˆ°çº¢è‰²
                        break;
                    case LARGE_BOMB:
                        color = `hsl(${Math.random() * 360}, 100%, 50%)`; // å…¨è‰²è°±
                        break;
                    default:
                        color = `hsl(${Math.random() * 60}, 100%, 50%)`;
                }
                
                // ç»˜åˆ¶ç²’å­
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ç»˜åˆ¶çˆ†ç‚¸ä¸­å¿ƒçš„å…‰åœˆ
            let gradient;
            switch(bombType) {
                case SMALL_BOMB:
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    break;
                case MEDIUM_BOMB:
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.2, 'rgba(255, 220, 0, 0.7)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                    gradient.addColorStop(0.8, 'rgba(255, 0, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    break;
                case LARGE_BOMB:
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    gradient.addColorStop(0.1, 'rgba(255, 255, 200, 0.9)');
                    gradient.addColorStop(0.3, 'rgba(255, 220, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.4)');
                    gradient.addColorStop(0.9, 'rgba(100, 0, 0, 0.2)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    break;
                default:
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(255, 0, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // ç¢°æ’æ£€æµ‹
        function collide() {
            // å®‰å…¨æ£€æŸ¥
            if (!player.piece) return false;
            
            const [m, o] = [player.piece, player.pos];
            
            // æ£€æŸ¥ç©å®¶ä½ç½®æ˜¯å¦åˆæ³•
            if (o === undefined || o.x === undefined || o.y === undefined) {
                return false;
            }
            
            for (let y = 0; y < m.length; y++) {
                // ç¡®ä¿è¡Œå­˜åœ¨
                if (!m[y]) continue;
                
                for (let x = 0; x < m[y].length; x++) {
                    if (m[y][x] !== 0 &&
                        (board[y + o.y] === undefined ||
                         board[y + o.y][x + o.x] === undefined ||
                         board[y + o.y][x + o.x] !== 0)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // ä¿®å¤åçš„æ—‹è½¬å‡½æ•° - å®ç°çœŸæ­£çš„90åº¦æ—‹è½¬
        function rotate() {
            // å¦‚æœæ²¡æœ‰æ–¹å—ï¼Œç›´æ¥è¿”å›
            if (!player.piece || player.piece.length === 0 || player.piece[0].length === 0) {
                return;
            }
            
            // åˆ›å»ºæ—‹è½¬åçš„æ–°çŸ©é˜µ
            const original = player.piece;
            const N = original.length;
            const M = original[0].length;
            const rotated = [];
            
            // åˆå§‹åŒ–æ—‹è½¬åçš„çŸ©é˜µ
            for (let i = 0; i < M; i++) {
                rotated[i] = new Array(N).fill(0);
            }
            
            // æ‰§è¡Œ90åº¦é¡ºæ—¶é’ˆæ—‹è½¬
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < M; x++) {
                    rotated[x][N - 1 - y] = original[y][x];
                }
            }
            
            // ä¿å­˜åŸå§‹ä½ç½®
            const originalPos = {...player.pos};
            const originalPiece = player.piece;
            
            // å°è¯•æ—‹è½¬
            player.piece = rotated;
            
            // å¦‚æœæ—‹è½¬åå‘ç”Ÿç¢°æ’ï¼Œå°è¯•è°ƒæ•´ä½ç½®
            if (collide()) {
                let offset = 1;
                while (offset <= 2) { // æœ€å¤šå°è¯•å·¦å³ç§»åŠ¨2æ ¼
                    // å°è¯•å‘å³ç§»åŠ¨
                    player.pos.x += offset;
                    if (!collide()) break;
                    
                    // å°è¯•å‘å·¦ç§»åŠ¨
                    player.pos.x = originalPos.x - offset;
                    if (!collide()) break;
                    
                    // æ¢å¤åŸå§‹ä½ç½®
                    player.pos.x = originalPos.x;
                    offset++;
                }
                
                // å¦‚æœè°ƒæ•´åä»ç„¶ç¢°æ’ï¼Œæ¢å¤åŸå§‹çŠ¶æ€
                if (collide()) {
                    player.piece = originalPiece;
                    player.pos = originalPos;
                }
            }
        }

        // æ¸…é™¤å®Œæ•´çš„è¡Œ
        function boardSweep() {
            let linesCleared = 0;
            outer: for (let y = board.length - 1; y >= 0; y--) {
                for (let x = 0; x < board[y].length; x++) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                y++;
                linesCleared++;
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100 * level;
                scoreElement.textContent = score;
                
                const newLevel = Math.floor(score / 1000) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    levelElement.textContent = level;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                }
            }
        }

        // é‡ç½®ç©å®¶ä½ç½®å’Œæ–¹å—
        function playerReset() {
            player.piece = createPiece();
            player.pos.y = 0;
            
            // ç¡®ä¿ player.piece å’Œ player.piece[0] å­˜åœ¨
            if (!player.piece || !player.piece[0]) {
                player.piece = [[1]]; // ä½¿ç”¨é»˜è®¤æ–¹å—
            }
            
            player.pos.x = Math.floor((COLS - player.piece[0].length) / 2);
            
            if (collide()) {
                gameOver = true;
                alert(`æ¸¸æˆç»“æŸ! æœ€ç»ˆå¾—åˆ†: ${score}`);
                board = createMatrix(COLS, ROWS);
                score = 0;
                level = 1;
                dropInterval = 1000;
                scoreElement.textContent = score;
                levelElement.textContent = level;
                gameOver = false; // é‡ç½®æ¸¸æˆçŠ¶æ€ï¼Œç¡®ä¿å¯ä»¥é‡æ–°å¼€å§‹
            }
        }

        // ç©å®¶æ§åˆ¶
        const player = {
            pos: {x: 0, y: 0},
            piece: null
        };

        // ç©å®¶ç§»åŠ¨
        function playerMove(dir) {
            // å®‰å…¨æ£€æŸ¥
            if (!player.piece || !player.pos) return;
            
            player.pos.x += dir;
            if (collide()) {
                player.pos.x -= dir;
            }
        }

        // ç©å®¶ä¸‹è½
        function playerDrop() {
            // å®‰å…¨æ£€æŸ¥
            if (!player.piece || !player.pos) return;
            
            player.pos.y++;
            if (collide()) {
                player.pos.y--;
                merge();
                boardSweep();
                playerReset();
            }
            dropCounter = 0;
        }

        // ä¸€é”®é€Ÿé™
        function hardDrop() {
            // å®‰å…¨æ£€æŸ¥
            if (!player.piece || !player.pos) return;
            
            // æ£€æŸ¥å½“å‰æ–¹å—æ˜¯å¦ä¸ºç‚¸å¼¹ï¼Œå¦‚æœæ˜¯åˆ™ç«‹å³å¼•çˆ†
            if (isBomb(player.piece)) {
                detonateBomb();
                return;
            }
            
            // é™åˆ¶ä¸‹è½æ¬¡æ•°ï¼Œé˜²æ­¢æ— é™å¾ªç¯
            let maxDrops = ROWS;
            while (!collide() && maxDrops > 0) {
                player.pos.y++;
                maxDrops--;
            }
            player.pos.y--;
            merge();
            boardSweep();
            playerReset();
            dropCounter = 0;
        }
        
        // æ£€æŸ¥æ–¹å—æ˜¯å¦ä¸ºç‚¸å¼¹
        function isBomb(piece) {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] === SMALL_BOMB || piece[y][x] === MEDIUM_BOMB || piece[y][x] === LARGE_BOMB) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // ç«‹å³å¼•çˆ†å½“å‰ç‚¸å¼¹
        function detonateBomb() {
            if (!player.piece || !player.pos) return;
            
            let bombX = -1, bombY = -1;
            let bombType = 0;
            let hasBomb = false;
            
            // å¯»æ‰¾ç‚¸å¼¹ä½ç½®ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ç‚¸å¼¹ï¼‰
            outer: for (let y = 0; y < player.piece.length; y++) {
                for (let x = 0; x < player.piece[y].length; x++) {
                    if (player.piece[y][x] === SMALL_BOMB || 
                        player.piece[y][x] === MEDIUM_BOMB || 
                        player.piece[y][x] === LARGE_BOMB) {
                        bombX = x + player.pos.x;
                        bombY = y + player.pos.y;
                        bombType = player.piece[y][x];
                        hasBomb = true;
                        break outer;
                    }
                }
            }
            
            if (hasBomb) {
                // ç«‹å³å¼•çˆ†ç‚¸å¼¹
                explodeBomb(bombX, bombY, bombType);
                
                // æ¸…é™¤å½“å‰æ–¹å—
                player.piece = null;
                
                // ç”Ÿæˆæ–°æ–¹å—
                playerReset();
            }
        }

        // æ¸¸æˆä¸»å¾ªç¯
        function update(time = 0) {
            if (gameOver) {
                // ä¸ç«‹å³é‡ç½®æ¸¸æˆçŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·å“åº”
                // gameOver = false;
                return;
            }
            
            // å¦‚æœæ¸¸æˆæš‚åœï¼Œåªç»˜åˆ¶å½“å‰çŠ¶æ€å¹¶ç»§ç»­è¯·æ±‚ä¸‹ä¸€å¸§
            if (paused) {
                // åœ¨ç”»é¢ä¸­å¤®æ˜¾ç¤ºæš‚åœä¿¡æ¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.font = '30px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText('å·²æš‚åœ', canvas.width / 2, canvas.height / 2);
                ctx.font = '16px Arial';
                ctx.fillText('æŒ‰å›è½¦é”®ç»§ç»­', canvas.width / 2, canvas.height / 2 + 30);
                
                requestAnimationFrame(update);
                return;
            }
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            
            draw();
            requestAnimationFrame(update);
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', event => {
            if (gameOver) return;
            
            if ([13, 32, 37, 38, 39, 40].includes(event.keyCode)) {
                event.preventDefault();
            }
            
            // å¤„ç†å›è½¦é”®æš‚åœ/ç»§ç»­
            if (event.keyCode === 13) { // å›è½¦é”®
                paused = !paused; // åˆ‡æ¢æš‚åœçŠ¶æ€
                return;
            }
            
            // å¦‚æœæ¸¸æˆå·²æš‚åœï¼Œä¸å¤„ç†å…¶ä»–æŒ‰é”®
            if (paused) return;
            
            switch (event.keyCode) {
                case 37: // å·¦ç®­å¤´
                    playerMove(-1);
                    break;
                case 39: // å³ç®­å¤´
                    playerMove(1);
                    break;
                case 40: // ä¸‹ç®­å¤´
                    playerDrop();
                    break;
                case 38: // ä¸Šç®­å¤´
                    rotate();
                    break;
                case 32: // ç©ºæ ¼é”®
                    hardDrop();
                    break;
            }
        });

        // æŒ‰é’®æ§åˆ¶
        document.getElementById('left').addEventListener('click', () => {
            if (!gameOver && !paused) playerMove(-1);
        });
        document.getElementById('right').addEventListener('click', () => {
            if (!gameOver && !paused) playerMove(1);
        });
        document.getElementById('rotate').addEventListener('click', () => {
            if (!gameOver && !paused) rotate();
        });
        document.getElementById('down').addEventListener('click', () => {
            if (!gameOver && !paused) playerDrop();
        });
        document.getElementById('drop').addEventListener('click', () => {
            if (!gameOver && !paused) hardDrop();
        });
        document.getElementById('pause').addEventListener('click', () => {
            if (!gameOver) paused = !paused;
        });

        // å¼€å§‹æ¸¸æˆ
        playerReset();
        update();
    </script>
</body>
</html>
